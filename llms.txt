# pbtsdb

> Type-safe PocketBase integration with TanStack Query and TanStack DB for React applications. Provides reactive collections with automatic real-time subscriptions, optimistic mutations, full TypeScript type safety, and minimal boilerplate.

This library connects PocketBase (backend-as-a-service) to TanStack's reactive database tools. Use it when building React applications that need real-time data synchronization with PocketBase while maintaining strict type safety.

## Core Pattern

```typescript
// 1. Define schema with type and relations properties
export type Schema = {
    books: {
        type: Book;
        relations: {
            author?: Author;
        };
    };
}

// 2. Create factory (once per app)
const factory = new CollectionFactory<Schema>(pb, queryClient);

// 3. Create collections with optional expand for type-safe relations
const booksCollection = factory.create('books', {
    expand: 'author' as const  // Use 'as const' for type inference
});

// 4. Use in React components with automatic subscriptions
const { data } = useLiveQuery((q) => q.from({ books: booksCollection }));
// Subscriptions start/stop automatically with component lifecycle
```

## React Integration

### CollectionsProvider (Optional)

Share collections across components using React Context:

```typescript
// App setup
const factory = new CollectionFactory<Schema>(pb, queryClient);
const collections = {
    books: factory.create('books'),
    authors: factory.create('authors'),
};

function App() {
    return (
        <CollectionsProvider collections={collections}>
            <YourApp />
        </CollectionsProvider>
    );
}

// In components
function BooksList() {
    const books = useStore('books'); // Single collection
    const { data } = useLiveQuery((q) => q.from({ books }));
}

function BooksWithAuthors() {
    const [books, authors] = useStore('books', 'authors'); // Multiple collections
    const { data } = useLiveQuery((q) =>
        q.from({ book: books })
            .join({ author: authors }, ({ book, author }) => eq(book.author, author.id))
    );
}
```

**useStore() API:**
- Single key: `useStore('books')` → returns `Collection<Books>`
- Multiple keys: `useStore('books', 'authors')` → returns `[Collection<Books>, Collection<Authors>]`
- Fully type-safe with automatic inference when using CollectionsRegistry augmentation

**Type Safety Setup:**
```typescript
// Augment CollectionsRegistry for automatic type inference
declare module 'pbtsdb' {
    interface CollectionsRegistry {
        books: Collection<Books>;
        authors: Collection<Authors>;
    }
}

// Now useStore has full type inference
const books = useStore('books'); // Type: Collection<Books>
const [books, authors] = useStore('books', 'authors'); // Tuple types preserved
```

## Key Concepts

- **CollectionFactory**: Create ONE factory per app, use it to create multiple collections
- **Collections are lazy**: No network activity until first query
- **Subscriptions are automatic**: Start when component mounts, stop 5s after unmount
- **Type-safe expand**: Use `as const` on expand strings for full TypeScript inference
- **Schema structure**: Use `type` and `relations` properties (lowercase, not `Row`/`Relations`)
- **Package name**: Import from `pbtsdb` (not `pocketbase-tanstack-db`)

## Testing

```bash
npm test  # Auto-resets DB, starts server, runs tests, stops server
```

Tests use real PocketBase instance (not mocked). Server infrastructure is fully automated.

## Documentation

- [AGENTS.md](AGENTS.md): Complete development guide with architecture, patterns, and testing
- [README.md](README.md): User-facing API reference with examples
- [test/schema.ts](test/schema.ts): Reference schema implementation

## Mutations

Collections support insert, update, and delete with automatic PocketBase sync:

```typescript
import { newRecordId } from 'pbtsdb';

// Insert with optimistic update (UI updates immediately)
const tx = collection.insert({
    id: newRecordId(), // Generate PocketBase-compatible ID
    title: 'New Book',
    // ... other fields
});

// Update with optimistic update
collection.update('record_id', (draft) => {
    draft.title = 'Updated Title';
});

// Update with config (non-optimistic - waits for server)
collection.update('record_id', { optimistic: false }, (draft) => {
    draft.title = 'Server-First Update';
});

// Delete with optimistic update
collection.delete('record_id');

// Batch mutations - merges multiple updates to same record
collection.utils.writeBatch(() => {
    collection.update('id1', (draft) => { draft.field1 = 'value1' });
    collection.update('id1', (draft) => { draft.field2 = 'value2' }); // Merged!
    collection.update('id2', (draft) => { draft.field = 'value' });
});

// Wait for persistence
await tx.isPersisted.promise; // States: pending → persisting → completed

// Custom handlers or disable mutations
const collection = factory.create('books', {
    onInsert: async ({ transaction }) => { /* custom logic */ },
    onUpdate: false, // Disable updates (throws error if called)
    onDelete: false, // Disable deletes
});
```

**Key Points:**
- Mutations are optimistic by default (UI updates immediately)
- Auto-syncs to PocketBase in background
- Batch mutations merge updates to same record
- Transaction states: pending → persisting → completed
- Use `newRecordId()` to generate PocketBase-compatible IDs

## Common Patterns

**Approach 1: Type-Safe Expand (Recommended)**
```typescript
const jobs = factory.create('jobs', { expand: 'customer,address' as const });
// Single PocketBase query, server-side join, fully typed expand property
```

**Approach 2: TanStack Joins (Advanced)**
```typescript
const jobs = factory.create('jobs', { relations: { customer: customersCollection }});
// Client-side joins with full type safety, supports inner/left/right/full joins
```

## Critical Rules

- NEVER use `any` types - defeats the purpose of this library
- ALWAYS use `as const` on expand strings for type inference
- Create ONE CollectionFactory instance per PocketBase connection
- Schema must match actual PocketBase collection structure
- Code should be self-documenting - avoid obvious comments

## Optional

### When NOT to Use

- Non-React environments (use PocketBase SDK directly)
- Simple CRUD without real-time (PocketBase SDK is simpler)
- Very large collections (>10k records - use pagination)
- Non-PocketBase backends (use TanStack Query directly)

### Package Details

- Requires React 18+, TypeScript 5.0+, PocketBase 0.21.0+
- Collections use TanStack Query for caching and TanStack DB for reactivity
- Real-time via PocketBase Server-Sent Events (SSE)
- Automatic reconnection with exponential backoff on subscription failures
